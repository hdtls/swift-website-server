import Fluent
import Vapor

///
/// NOTE: This file was generated by Fluent.swift.gyb
///
/// Do NOT edit this file directly as it will be regenerated automatically when needed.
///
%{
import json
import os
import re
import sys

MODULE_DIR = os.path.dirname(os.path.realpath(__file__))
FLUENT_FILE = os.path.join(MODULE_DIR, "Fluent.json")

try:
    fluent_definition = json.load(open(FLUENT_FILE))
except OSError as e:
    print("FAIL: GENERATING .gyb fiels failed", file=sys.stderr)
    sys.exit(e.errno)

"""
Define field_properties.

Field property keys should contains in:
    - `field_id`: int, optional
        - "Field" or None: FieldProperty or OptionalFieldProperty
        - "Enum"
        - "ID": ID
        - "Parent": ParentProperty or OptionalParentProperty
        - "OptionalChild": OptionalChildProperty
        - "Children": ChildrenProperty
        - "Siblings: SiblingsProperty
    - `field_key`: FieldKey, optional, by default, automatically generated by `name`.
    - `name`: required
    - `type`: required
    - `codable`: optional, If None use `type` instead.
    - `exclude_from_codable`: optional, If True serializing protocol will not contains this field.
    - `parent_field`: optional, Only available when `field_id == "Parent"`.
    - `through`: optional, Only available when `field_id == "Siblings"`.
    - `parent_from_field`: optional, Only available when `field_id == "Siblings"`.
    - `parent_to_field`: optional, Only available when `field_id == "Siblings"`.
"""

def convert_to_snake_case(name):
    return name[0].lower() + "".join("_" + character.lower() if character.isupper() else character for character in name[1:])

def obj_getClass(obj):
    return EMIT_KIND

def obj_getDTOClass(obj):
    return obj[EMIT_KIND].get("codable", "DTO")

def obj_getProperties(obj):
    return obj[EMIT_KIND]["properties"]

def needs_generate_fieldkeys(field_properties):
    return filter(
        lambda field: not (
            property_getFieldType(field)
            in ["Children", "Siblings"]
            or field.get("field_key")
            or property_getName(field) == "id"
        ),
        field_properties,
    )

def property_getFieldkey(field):
    return field.get("field_key", "FieldKeys." + property_getName(field))

def property_getName(field):
    return field["name"]

def property_getAttribute(field, field_property=True):
    if field_property:
        return field.get("type", "String")
    return field.get("codable", field.get("type", "String")) if property_getName(field) != "id" else field.get("type", "String")[:-1]

def property_getFieldType(field):
    return field.get("field_id", "Field") if property_getName(field) != "id" else "ID"

def is_optional(property_attribute):
    return property_attribute.endswith("?")

def filtered_available_properties(field_properties):
    return filter(lambda field: not field.get("exclude_from_codable"), field_properties)
}%

final class ${obj_getClass(fluent_definition)}: Fluent.Model {

    static let schema: String = "${fluent_definition[EMIT_KIND]["schema"]}"
% for field in obj_getProperties(fluent_definition):

%   if property_getFieldType(field) == "ID":
    ${"@ID()" if property_getAttribute(field) == "UUID?" else "@ID(custom: .id)"}
%   elif property_getFieldType(field) in ["Field", "Enum", "Parent"]:
    ${"@{}{}(key: {})".format(("Optional" if is_optional(property_getAttribute(field)) else ""), property_getFieldType(field), property_getFieldkey(field))}
%   elif property_getFieldType(field) == "OptionalChild":
    @OptionalChild(for: \.${field.get("parent_field")})
%   elif property_getFieldType(field) == "Children":
    @Children(for: \.${field.get("parent_field")})
%   elif property_getFieldType(field) == "Siblings":
    @Siblings(through: ${field["through"]}, from: \.${field["parent_from_field"]}, to: \.${field["parent_to_field"]})
%   end
    var ${property_getName(field)}: ${property_getAttribute(field)}
% end
    
    @Timestamp(key: .createdAt, on: .create)
    var createdAt: Date?
    
    @Timestamp(key: .updatedAt, on: .update)
    var updatedAt: Date?
}

% if needs_generate_fieldkeys(obj_getProperties(fluent_definition)):
extension ${obj_getClass(fluent_definition)} {
    
    struct FieldKeys {
% for field in needs_generate_fieldkeys(obj_getProperties(fluent_definition)):
%   if property_getFieldType(field) == "Parent":
        static let ${property_getName(field)}: FieldKey = "${convert_to_snake_case(property_getName(field))}_id"
%   else:
        static let ${property_getName(field)}: FieldKey = "${convert_to_snake_case(property_getName(field))}"
%   end
% end
    }
}
%end

extension ${obj_getClass(fluent_definition)}: Bridgeable {
    
    %if obj_getDTOClass(fluent_definition) != "DTO":    
    typealias DTO = ${obj_getDTOClass(fluent_definition)}
    
    %end
    static func fromBridgedDTO(_ dataTransferObject: ${obj_getDTOClass(fluent_definition)}) throws -> ${obj_getClass(fluent_definition)} {
        let model = ${obj_getClass(fluent_definition)}.init()
%   for field in filtered_available_properties(obj_getProperties(fluent_definition)):
%       if property_getFieldType(field) in ["ID", "Field", "Enum"]:
%           if is_optional(property_getAttribute(field, False)):
%               if is_optional(property_getAttribute(field)):
        model.${property_getName(field)} = dataTransferObject.${property_getName(field)}
%               else:
        guard let ${property_getName(field)} = dataTransferObject.${property_getName(field)} else {
            throw Abort(.badRequest, reason: "Value required for key '${property_getName(field)}'", identifier: "keyNotFound")
        }
        model.${property_getName(field)} = ${property_getName(field)}
%               end
%           else:
        model.${property_getName(field)} = dataTransferObject.${property_getName(field)}
%           end
%       elif property_getFieldType(field) == "Parent":
%           if is_optional(property_getAttribute(field)):
        model.$$${property_getName(field)}.id = dataTransferObject.${property_getName(field)}Id
%           else:
%               if is_optional(property_getAttribute(field, False)):
        guard let ${property_getName(field)}Id = dataTransferObject.${property_getName(field)}Id else {
            throw Abort(.badRequest, reason: "Value required for key '${property_getName(field)}Id'", identifier: "keyNotFound")
        }
        model.$$${property_getName(field)}.id = ${property_getName(field)}Id
%               else:
        model.$$${property_getName(field)}.id = dataTransferObject.${property_getName(field)}Id
%               end
%           end
%       end
% end
        return model
    }
    
    func bridged() throws -> ${obj_getDTOClass(fluent_definition)} {
% if obj_getDTOClass(fluent_definition) == obj_getClass(fluent_definition):
        return self
% else:
        var dataTransferObject = DTO.init()
%   for field in filtered_available_properties(obj_getProperties(fluent_definition)):
%        if property_getFieldType(field) == "ID":
        dataTransferObject.id = try requireID()
%        else:
%{
            if is_optional(property_getAttribute(field, False)):
                if property_getFieldType(field) == "Field":
                    suffix = "{}".format(" ?? nil" if is_optional(property_getAttribute(field)) else "")
                elif property_getFieldType(field) == "Enum":
                    suffix = "{}".format(" ?? nil" if is_optional(property_getAttribute(field)) else "")
                elif property_getFieldType(field) in ["Parent", "OptionalChild"]:
                    suffix = "{}?.bridged()".format("?" if is_optional(property_getAttribute(field)) else "")
                else:
                    suffix = "?.map({ try $0.bridged() })"
            else:
                if property_getFieldType(field) == "Field":
                    suffix = " ?? .init()"
                elif property_getFieldType(field) == "Enum":
                    suffix = " ?? .allCases.first!"
                elif property_getFieldType(field) in ["Parent", "OptionalChild"]:
                    suffix = "{}?.bridged() ?? .init()".format("?" if is_optional(property_getAttribute(field)) else "")
                else:
                    suffix = "?.map({ try $0.bridged() }) ?? []"
}%
%       if property_getFieldType(field) == "Parent":
        dataTransferObject.${property_getName(field)}Id = $$${property_getName(field)}.$id.value ?? nil
%       end
        dataTransferObject.${property_getName(field)} = ${"{}${}.value{}".format(
            ("" if property_getFieldType(field) in ["Field", "Enum"] else "try "),
            property_getName(field),
            suffix
            )}
%    end
% end
        return dataTransferObject
% end
    }
}

extension ${obj_getClass(fluent_definition)}: Updatable {
    
    func update(with dataTransferObject: DTO) throws {
%   for field in filter(lambda field: not (property_getFieldType(field) == "ID" or field.get("exclude_from_codable")), obj_getProperties(fluent_definition)):
%       if property_getFieldType(field) in ["ID", "Field", "Enum"]:
%           if is_optional(property_getAttribute(field, False)):
%               if is_optional(property_getAttribute(field)):
        ${property_getName(field)} = dataTransferObject.${property_getName(field)}
%               else:
        guard let ${property_getName(field)} = dataTransferObject.${property_getName(field)} else {
            throw Abort(.badRequest, reason: "Value required for key '${property_getName(field)}'", identifier: "keyNotFound")
        }
        self.${property_getName(field)} = ${property_getName(field)}
%               end
%           else:
        ${property_getName(field)} = dataTransferObject.${property_getName(field)}
%           end
%       elif property_getFieldType(field) == "Parent":
%           if is_optional(property_getAttribute(field)):
        $$${property_getName(field)}.id = dataTransferObject.${property_getName(field)}Id
%           else:
%               if is_optional(property_getAttribute(field, False)):
        guard let ${property_getName(field)}Id = dataTransferObject.${property_getName(field)}Id else {
            throw Abort(.badRequest, reason: "Value required for key '${property_getName(field)}Id'", identifier: "keyNotFound")
        }
        $$${property_getName(field)}.id = ${property_getName(field)}Id
%               else:
        $$${property_getName(field)}.id = dataTransferObject.${property_getName(field)}Id
%               end
%           end
%       end
% end
    }
}

extension ${obj_getClass(fluent_definition)} {
    
    struct ${obj_getDTOClass(fluent_definition)}: Codable, Equatable {
%   for field in filtered_available_properties(obj_getProperties(fluent_definition)):
        var ${property_getName(field)}: ${property_getAttribute(field, False)}
%       if property_getFieldType(field) == "Parent":
        var ${property_getName(field)}Id: ${property_getAttribute(field)}.IDValue?
%       end
%   end

        init() {
%   for field in filtered_available_properties(obj_getProperties(fluent_definition)):
%       if not is_optional(property_getAttribute(field, False)):
%           if property_getFieldType(field) == "Enum":
            ${property_getName(field)} = .allCases.first!
%           else:
            ${property_getName(field)} = .init()
%           end
%       end
%   end           
        }
    }
}

extension ${obj_getClass(fluent_definition)}.${obj_getDTOClass(fluent_definition)}: Content {}
