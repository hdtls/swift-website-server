#!/usr/bin/env python3

"""
The ultimate tool for building books.
"""

import argparse
import os
from pathlib import Path
import subprocess
import sys
import tempfile
from typing import Any, List, Literal, Optional, Union


PACKAGE_DIR = Path(".")
LIBRARY_DIR = PACKAGE_DIR.joinpath("Sources", "Backend")
PACKAGE_NAME = "swift-blog"
PRODUCT_NAME = "swift-blog"
TOOLCHAIN = "/usr"

GYB_EXEC = PACKAGE_DIR.joinpath("utils", "gyb").as_posix()

BASE_KIND_FILES = [
    "Blog",
    "BlogCategory",
    "Education",
    "Experience",
    "Industry",
    "Project",
    "Skill",
    "SocialNetworking",
    "SocialNetworkingService",
    "User",
]


def printerr(message: object):
    print(message, file=sys.stderr)


def fatal_error(message: object):
    printerr(message)
    sys.exit(1)


def escape_cmd_arg(arg: str):
    if '"' in arg or " " in arg:
        return '"%s"' % arg.replace('"', '\\"')
    else:
        return arg

_CMD = Union[str, List[str]]
_CONFIG = Optional[Literal["debug", "release"]]

def call(cmd: _CMD, verbose: Optional[bool], env=os.environ, stdout: int = None):
    if verbose:
        if isinstance(cmd, str):
            print(escape_cmd_arg(cmd))
        else:
            print(" ".join([escape_cmd_arg(arg) for arg in cmd]))
    return subprocess.call(cmd, env=env, stdout=stdout, stderr=subprocess.STDOUT)


def check_call(cmd: _CMD, verbose: Optional[bool], cwd: Path = None, env=os.environ):
    if verbose:
        if isinstance(cmd, str):
            print(escape_cmd_arg(cmd))
        else:
            print(" ".join([escape_cmd_arg(arg) for arg in cmd]))
    return subprocess.check_call(cmd, cwd=cwd, env=env, stderr=subprocess.STDOUT)


def check_gyb_exec(exec: Optional[str]):
    if not (exec and Path(exec).exists()):
        fatal_error(
            """
Error: Could not find gyb.
Looking at '%s'.
"""
            % exec
        )


def check_rsync():
    with open(os.devnull, "w") as DEVNULL:
        if call(["rsync", "--version"], verbose=False, stdout=DEVNULL) != 0:
            fatal_error("Error: Could not find rsync.")


def generate_xcodeproj(config: Optional[Union[Path, str]]):
    print("Generate {} as an Xcode project".format(PRODUCT_NAME))
    os.chdir(PACKAGE_DIR)

    popenargs = ["swift", "package", "generate-xcodeproj"]

    if config:
        if isinstance(config, str):
            config = Path(config)
            
        popenargs.extend(["--xcconfig-overrides", config.as_posix()])

    check_call(popenargs)


def _generate_file_from_gyb_file(
    exec: Union[Path, str],
    input_file: Path,
    output_file_name: str,
    destination: Path,
    temp_files_dir: Path,
    verbose: Optional[bool],
    other_flags: List[str] = [],
):
    if isinstance(exec, Path):
        exec = exec.as_posix()

    popenargs = [
        sys.executable,
        exec,
        input_file.as_posix(),
        "--line-directive=",
        "-o",
        temp_files_dir.joinpath(output_file_name).as_posix(),
    ]

    popenargs += other_flags

    check_call(popenargs, verbose=verbose)

    # Copy the file if different from the file already present in
    # gyb
    popenargs = [
        "rsync",
        "--checksum",
        temp_files_dir.joinpath(output_file_name).as_posix(),
        destination.joinpath(output_file_name).as_posix(),
    ]

    check_call(popenargs, verbose=verbose)


def _generate_files_from_gyb_template(
    exec: Union[Path, str],
    src: Path,
    dst: Path,
    tags: List[str],
    temp_files_dir: Path,
    verbose: Optional[bool],
):
    for tag in tags:
        _generate_file_from_gyb_file(
            exec=exec,
            input_file=src,
            output_file_name=tag + ".swift",
            destination=dst,
            temp_files_dir=temp_files_dir,
            other_flags=["-DEMIT_KIND=%s" % tag],
            verbose=verbose,
        )


def generate_files(exec: Union[Path, str], verbose: Optional[bool]):
    if verbose:
        print("Planning generate files")
    print("Generating files...")

    check_gyb_exec(exec)
    check_rsync()

    temp_files_dir = Path(tempfile.gettempdir())
    temp_files_dir.mkdir(parents=True, exist_ok=True)

    parent = None
    # Auto generate files that defined in gyb file.
    for path in LIBRARY_DIR.rglob("*.gyb"):
        destination = path.parent.joinpath("autogenerated")
        if not destination.exists():
            destination.mkdir(parents=True, exist_ok=True)

        if parent != path.parent:
            _remove_autogenerated_files(path.parent, destination, verbose)
            parent = path.parent

        _generate_file_from_gyb_file(
            exec,
            path,
            path.name[:-4],
            destination,
            temp_files_dir,
            verbose,
        )

    # Auto generate files that defined in gyb template.
    for path in LIBRARY_DIR.rglob("*.gyb.template"):
        destination = path.parent.joinpath("autogenerated")
        if not destination.exists():
            destination.mkdir(parents=True, exist_ok=True)

        if parent != path.parent:
            _remove_autogenerated_files(path.parent, destination, verbose)
            parent = path.parent

        _generate_files_from_gyb_template(
            exec, path, destination, BASE_KIND_FILES, temp_files_dir, verbose
        )

    print("Generate complete!")


# Remove any files in the `gyb` directory that no longer have a
# corresponding `.gyb` file in the `Sources` directory.
def _remove_autogenerated_files(src: Path, dst: Path, verbose: Optional[bool],):
    for dir in dst.glob("*.swift"):
        path = src.joinpath(dir.name, ".gyb")

        if not ((dir.name[:-6] in BASE_KIND_FILES) or path.exists()):
            check_call(["rm", dir], cwd=dst, verbose=verbose)


def get_swiftpm_invocation(
    toolchain: Union[Path, str],
    action: str,
    configuration: _CONFIG,
):
    if isinstance(toolchain, str):
        toolchain = Path(toolchain)

    swift = toolchain.joinpath("bin", "swift")

    popenargs = [swift.as_posix(), action]
    popenargs.extend(["--package-path", PACKAGE_DIR])
    popenargs.extend(["--configuration", configuration])

    return popenargs


def run_build(
    toolchain: Union[Path, str],
    product: str,
    configuration: _CONFIG,
    static_swift_stdlib: Optional[bool],
    verbose: Optional[bool],
):
    popenargs = get_swiftpm_invocation(toolchain, "build", configuration)

    if verbose:
        popenargs.append("--verbose")

    print("Planing build product " + PRODUCT_NAME)

    popenargs.extend(["--product", product])

    if static_swift_stdlib:
        popenargs.append("--static-swift-stdlib")

    check_call(popenargs, verbose)


def run_tests(
    toolchain: Union[Path, str],
    configuration: _CONFIG,
    parallel: Optional[bool],
    verbose: Optional[bool],
):
    if verbose:
        print("Planning run tests")
    print("Running tests for product {}".format(PRODUCT_NAME))

    success = run_xctests(
        toolchain=toolchain,
        configuration=configuration,
        parallel=parallel,
        verbose=verbose,
    )

    return success


def run_xctests(
    toolchain: Union[Path, str],
    configuration: _CONFIG,
    parallel: Optional[bool],
    verbose: Optional[bool],
):
    popenargs = get_swiftpm_invocation(
        toolchain=toolchain,
        action="test",
        configuration=configuration,
    )

    if verbose:
        popenargs.append("--verbose")

    if parallel:
        popenargs.append("--parallel")

    popenargs.extend(["--test-product", "{}PackageTests".format(PACKAGE_NAME)])

    return call(popenargs, verbose=verbose) == 0


# -----------------------------------------------------------------------------
# Arugment Parsing

_DESCRIPTION = """
Build and test script for {0}.

Build {0} by generating all necessary files form the corresponding
.swift.gyb files first.

It is not necessary to build the compiler project.

The build script can also drive the test suite included in the {0}
repo. This requires a custom build of the compiler project since it accesses
test utilities that are not shipped as part of the toolchains. See the Testing
section for arguments that need to be specified for this.
""".format(
    PRODUCT_NAME
)


def parse_args():
    parser = argparse.ArgumentParser(
        formatter_class=argparse.RawDescriptionHelpFormatter, description=_DESCRIPTION
    )

    parser.add_argument(
        "-v", "--verbose", action="store_true", help="Enable verbose logging."
    )

    xcode_project_group = parser.add_argument_group("Xcode Project")

    xcode_project_group.add_argument(
        "--generate-xcodeproj",
        action="store_true",
        help="Generate an Xcode project for {}.".format(PRODUCT_NAME),
    )

    xcode_project_group.add_argument(
        "--xcconfig-path",
        help="The path to an xcconfig file for generating Xcode projct.",
    )

    build_group = parser.add_argument_group("Build")

    build_group.add_argument(
        "-c",
        "--configuration",
        default="debug",
        help="Build with configuration (default: %(default)s).",
    )

    build_group.add_argument(
        "--degyb-only",
        action="store_true",
        help="The script only generates swift files from gyb and skips the "
        "rest of the build",
    )

    build_group.add_argument(
        "--toolchain",
        default=TOOLCHAIN,
        help="The path to the toolchain that shall be used to build {} (default: %(default)s).".format(
            PRODUCT_NAME
        ),
    )

    build_group.add_argument(
        "--static-swift-stdlib",
        action="store_true",
        default=False,
        help="Link Swift stdlib statically (default: %(default)s).",
    )

    test_group = parser.add_argument_group("Test")

    test_group.add_argument("-t", "--test", action="store_true", help="Run tests")

    test_group.add_argument(
        "--gyb",
        default=GYB_EXEC,
        help="Path to the gyb tool (default: %(default)s).",
    )

    test_group.add_argument(
        "--parallel",
        action="store_true",
        help="Run the tests in parallel.",
    )

    return parser.parse_args()


def main():
    args = parse_args()

    try:
        generate_files(args.gyb, verbose=args.verbose)
    except subprocess.CalledProcessError as e:
        printerr("FAIL: Generating .gyb files failed")
        printerr("Executing: %s" % " ".join(e.cmd))
        fatal_error(e.output)

    # Skip the rest of the build if we should perform degyb only
    if args.degyb_only:
        sys.exit(0)

    if args.generate_xcodeproj:
        generate_xcodeproj(config=args.xcconfig_path)
        sys.exit(0)

    try:
        run_build(
            toolchain=args.toolchain,
            product=PRODUCT_NAME,
            configuration=args.configuration,
            static_swift_stdlib=args.static_swift_stdlib,
            verbose=args.verbose,
        )
    except subprocess.CalledProcessError as e:
        printerr("FAIL: Building product failed")
        printerr("Executing: %s" % " ".join(e.cmd))
        fatal_error(e.output)

    if args.test:
        try:
            success = run_tests(
                toolchain=args.toolchain,
                configuration=args.configuration,
                parallel=args.parallel,
                verbose=args.verbose,
            )
            if not success:
                # An error message has already been printed by the failing test
                # suite
                sys.exit(1)
            else:
                print("All tests passed!")
        except subprocess.CalledProcessError as e:
            printerr("FAIL: Running tests failed")
            printerr("Executing: %s" % " ".join(e.cmd))
            fatal_error(e.output)


if __name__ == "__main__":
    try:
        sys.exit(main())
    except KeyboardInterrupt:
        sys.exit(1)
